-# Basic ReQL

# Getting to Know ReQL

RethinkDB uses a special syntax call ReQL to interactive with the data. ReQL is
chainable. You start with a table, and chain to other API to get what you want,
in a way very natural. Eg.

```
r.db("test").table('movie').filter({'type': 'anime'})
```

Don't worry about the syntax, just look at it again and even without any
knowledge you know what it does and easily remember it. A way, for me, to
understand ReQL is that every command return an object which can be pass into
next command. 

ReQL is particular to your language. Though, of course, they will look familiar
between different language to maintain consitent look and feel. But, they are
different. Those querie are constructed by making function call of your
language, not by concat SQL String, or not by special JSON object like MongoDB.
Therefore, it feel very natualy to write ReQL. As if the document we manipulate
is an object in our language. 

RethinkDB supports 3 official drives:
 
* Ruby
* NodeJS
* Python 

These support all [driver specifications](http://rethinkdb.com/docs/driver-spec/). The community drives such as Go, PHP probably won't support them all, if you used a different language and find something isn't right, it is probably not your fault.


All ReQL starts with r, its top level module to expose its public API. In
NodeJS, we can use

    var r = require('rethinkdb')

or Ruby

    require 'rethinkdb'
    include RethinkDB::Shortcuts
    puts r.inspect

Once we constructed ReQL with `r`, we have to call `run` method to execute it. The
command will be submit to an active database connection. The database connection
can be establish with `connect`

```
var r = require('rethinkdb')
var p = r.connect({
  host: '127.0.0.1', 
  post: '28015', 
  db: 'test'
}, function (err, conn) {
  
  r.table('post').get(1).run(conn)
})
```

However, most of the time, we will use Data Exploer. Therefore we can use r without 
initialization and call `run` method

Thinking ReQL like the pipe or stream, you select the data, narrow down it or
transform it and pass it to the next command. 

Taking direcly from RethinkDB doc, we have 3 composite data types.

* Streams 

:are lists like arrays, but they're loaded in a lazy fashion. Operations that return streams return a cursor. A cursor is a pointer into the result set. Instead of reading the results all at once like an array, you loop over the results, retrieving the next member of the set with each iteration. This makes it possible to efficiently work with large result sets. (See "Working with Streams," below, for some tips.) Streams are read-only; you can't pass one as an input to an ReQL command meant to modify its input like update or delete.

* Selections represent subsets of tables, for example, the return values of filter or get. There are two kinds of selections, Selection<Object> and Selection<Stream>, which behave like objects or streams respectively. The difference between selections and objects/streams are that selections are writable--their return values can be passed as inputs to ReQL commands that modify the database. For instance, the get command will return a Selection<Object> that could then be passed to an update or delete command.

* Tables are RethinkDB database tables. They behave like selections—they're writable, as you can insert and delete documents in them. ReQL methods that use an index, like getAll, are only available on tables.

Understanding this concept is important. It allows you to read and understand
RethinkDB API, know where you can chain a command.

Each ReQL method can be call on one or many above data types. Take `update` command, when you browser the API
document, you see

    table.update(json | expr[, {durability: "hard", returnVals: false, nonAtomic: false}]) → object

    selection.update(json | expr[, {durability: "hard", returnVals: false, nonAtomic: false}]) → object

    singleSelection.update(json | expr[, {durability: "hard", returnVals: false, nonAtomic: false}]) → object

It means the command can be invoked on a table, or selection (eg: first 30
element of tables), or a single selection - a document is an example of single
selection.


### Selecting data


#### Select the whole table

Let's get all data in table `county_stat`, database `test` which we imported
before. This is same as `SELECT * FROM table` in SQL.

    r.db('tets').table('input_polls')

    [
      {
      "Date":  "Jan 16" ,
      "Day": 14 ,
      "Dem": 50 ,
      "EV": 12 ,
      "GOP": 39 ,
      "Len": 5 ,
      "Pollster":  "SurveyUSA-5" ,
      "id":  "Washington" ,
      "uuid":  "0670d6e4-7b56-4259-b5f2-4dbc5186fcca"
      } ,
      {
      "Date":  "Apr 05" ,
      "Day": 93.5 ,
      "Dem": 47 ,
      "EV": 15 ,
      "GOP": 47 ,
      "Len": 4 ,
      "Pollster":  "Marist Coll.-4" ,
      "id":  "North Carolina" ,
      "uuid":  "0788843d-a342-4402-9c47-f6522e7bc216"
      } ,
      {
      "Date":  "May 14" ,
      "Day": 131.5 ,
      "Dem": 49 ,
      "EV": 14 ,
      "GOP": 39 ,
      "Len": 6 ,
      "Pollster":  "Quinnipiac U.-6" ,
      "id":  "New Jersey" ,
      "uuid":  "08acce74-9d7d-4baa-a0ee-2b5d6520ae82"
      } ,
      ...
    ]

You should get back an array of JSON object. By default, the data explorer will
automatically paginate it.

> Note: you can drop r.table() without r.db() if the table is in current
> selected databas. Without any indication, the default database is `test`.
> Just like in SQL, you can run `use database` and don't have to type
> `database.table_name`. 


#### Select a single document by its primary key

To select a single element, we call `get` on a table, and passing its primary
key value.

    r.table('input_polls').get('08acce74-9d7d-4baa-a0ee-2b5d6520ae82')
    # will return
    {
      "Date":  "May 14" ,
      "Day": 131.5 ,
      "Dem": 49 ,
      "EV": 14 ,
      "GOP": 39 ,
      "Len": 6 ,
      "Pollster":  "Quinnipiac U.-6" ,
      "id":  "New Jersey" ,
      "uuid":  "08acce74-9d7d-4baa-a0ee-2b5d6520ae82"
    }

> Note: This time, we drop `.db('test')` and just use `r.table()`. It's shorter
> and it works. If you are working on database `test` and want to access table
> in database `db1`, u have to use `r.db('db1').table(...)`

Every document in RethinkDB has to include a primary field, its value is
unique across cluster and is used to identify the document. The name of primary 
field is `id` by default. However, when you create a table, you have an option to change name of primary field.
Like in above table, the primary field's name is `*uuid*`, not `*id*`. We will learn
more about it later. Just keep a note here.

In RethinkDB, using of incremental primary key isn't recommended because that's
hard in a cluster environment. To make sure
the uniqueness of the new value, We have to check in every clusters
somehow. RethinkDB team decide[^pr] to use an unique id instead of an
incremental value.

#### Select many document by value of fields

We used `*filter*` method, and passing an Let's find all poll on May 14.

    r.table('input_polls').filter({day: 'May 14'})
    #=>  
    [
        {
        "Date":  "May 14" ,
        "Day": 131.5 ,
        "Dem": 49 ,
        "EV": 14 ,
        "GOP": 39 ,
        "Len": 6 ,
        "Pollster":  "Quinnipiac U.-6" ,
        "id":  "New Jersey" ,
        "uuid":  "08acce74-9d7d-4baa-a0ee-2b5d6520ae82"
        } ,
        {
        "Date":  "May 14" ,
        "Day": 134 ,
        "Dem": 43 ,
        "EV": 15 ,
        "GOP": 51 ,
        "Len": 1 ,
        "Pollster":  "Rasmussen-1" ,
        "id":  "North Carolina" ,
        "uuid":  "b3d2024b-92c0-4852-bb8c-50c10591cac3"
        }
    ]    

[^pr]: Check http://stackoverflow.com/questions/21020823/unique-integer-counter-in-rethinkdb

Not just that, if we pass many value into `filter`, it will be filter as well. 

    r.table('input_polls').filter({Date: 'May 14', Day: 134})
    #=>  
    [
        {
        "Date":  "May 14" ,
        "Day": 134 ,
        "Dem": 43 ,
        "EV": 15 ,
        "GOP": 51 ,
        "Len": 1 ,
        "Pollster":  "Rasmussen-1" ,
        "id":  "North Carolina" ,
        "uuid":  "b3d2024b-92c0-4852-bb8c-50c10591cac3"
        }
    ]    

With simple filterting, we can easily pass an filter object as above. But what
up with complex searching? Like we want to find all polls happen in May, and
have the GOP greater than 30

    r.tablle()

If you notice, we did't specify any fields in all our above query. That's bad.
We don't need to rob what we don't want. Let's narrow down them

    r.table()
      .pluck()

How about if we want to get only a single fields, like we want to get a list of
id of input_polls. `pluck` works of course, but we have a shortcut here

    r.table('input_polls')(field)

`filter` seems handy but it's actually limited. `filter` didn't leverage index.
It scan and hold all data in memory. Of course, this isn't scale infinite. Only
100,000 record can be filter.

A thing you should know is RethinkDB doesn't order docuement based on time they
are inserted by default. The order seems in an unpredicted way. In MySQL, for
example, even without any index, the default order will be exactly same as you
insrted the document. However, in RethinkDB it doesn't. I guess this is because
it's distributed.

Also, because ReQL is built into your language. You can do many amazing thing
without had to deal to crete ugly and complex SQL. 

Look at our `input_polls` table, we want to filter only the poll happen on
Sunday in Minnesota, and all the poll on Monday at Virginia.

    r.table('input_polls').filter(
		  r.js("(function (p) { var d = new Date(Date.parse(p.Date + ' 2014')); return p.id=='Minnesota' && d.getDay()==0;})")
    )

    r.table('input_polls').filter(
		  r.js("(function (p) { var d = new Date(Date.parse(p.Date + ' 2014')); return (p.id=='Minnesota' && d.getDay()==0) || (p.id=='Virgina' && d.getDay()==2) ;})")
    )

The syntax may ugly at this moment because we have to pass the JavaScript code
as a single string. But the potential is huge. Those kind of tricky query can
get hard with SQL. Now we can simply explain in our own language with eventually
complex business logic rule

We will learn more about advanced query in other chapter. For now, let's move on
and try to write some data into RethinkDB.

## What did we gain

We now have some basic understanding:

1. ReQL always starts with `r`
2. ReQL is tie to your language
3. Find an document by its primary 
4. Access table data and filter data by some condition

If anything you don't understand, or not sure, please re-read this chapter.
