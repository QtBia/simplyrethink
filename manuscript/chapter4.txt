# Modifying data

We will address database command, then table command, and then document command
on this chapter.

## Database

All commands on database levels start at the top namespace `r`. 

### Create

These are very simple. Probably with example you get it instanly

    //Create database
    r.dbCreate("db1")
    #=>
    {
      "created": 1
    }

If creating succesfully, we get back the object with `created` is *1*. We can
confirm by listing what we have:

    r.dbList()
    #=>
    [
    "test" ,
    "db1"
    ]

### Drop
So we got the default test and db1 is what we just have. Since we don't use db1,
let delete it to keep it clean. 

    r.dbDrop('db1')
    #=>
    {
      "dropped": 1
    }

The object we got back let us know the result in `*dropped*` field.

        

## Table

Tables have to sit inside a database, therefore, all table command have to call
on a database. When you don't use 

The syntax to create a table is

    db.tableCreate(tableName[, options])

The second parameter is optional, including following value:

primaryKey
: the name of primary key. As mention before, default name of primary key is
**id**. Using this option, you can change that default behaviou like we used
`*uuid*` with our input_polls table.

durability
: accept value of *soft* or *hard*. *soft* means the writes will be
acknowledge by server immdediately and data will be flushed to disk in
background. If you write a large chunk of data. The opposite of soft, is hard,
the default behaviour is to acknowledge after data is written to disk.
Therefore, it will be longer. When you don't need the data consitent, such as
writing a cache, or an important log, you should set durability to soft to
increase speed

datacenter
: the name of the datacenter this table should be assigned to.

To list what table we has, call `tableList()`. To get rid of the table, use
`*tableDrop(tablename)*`. 
  
    r.tableList()
    //=>
    [
        "county_stats" ,
        "input_polls"
    ]

    r.tableCreate('foo')
    //=>
    {
      "created": 1
    }    
    r.tableCreate('foo2', {durability: 'soft'})
    //=>
    {
      "created": 1
    }

    r.tableList()
    //=>
    [
      "foo2" ,
      "county_stats" ,
      "input_polls" ,
      "foo"
    ] 
    r.tableDrop('foo') 
    //=>
    {
      "dropped": 1
    }
    r.tableDrop('foo2') 
    //=>
    {
      "dropped": 1
    }
    r.tableList()
    //=>
    [
        "county_stats" ,
        "input_polls"
    ]

Notice how RethinkDB returns a consitent JSON schema for database and table
creating, drop with `created`, `dropped` field. 
    
# Insert document

As you can guess now, we will start from the database, chain the table, and use
`*insert*` method to insert a document into the table. Eg

    r.db('test').table('input_polls').insert({
      id: 'foo',
      Day: 120,
      Date: 'May 2',
      Dem: '49'
    })
    
    #=>
    {
      "deleted": 0 ,
      "errors": 0 ,
      "generated_keys": [
      "13556cd8-034c-4c0e-91c0-666230740121"
      ] ,
      "inserted": 1 ,
      "replaced": 0 ,
      "skipped": 0 ,
      "unchanged": 0
    }

The return object contains following attributes. 

inserted
: the number of documents that were succesfully inserted.

replaced
: the number of documents that were updated when upsert is used.

unchanged
: the number of documents that would have been modified, except that the new value was the same as the old value when doing an upsert.

errors
: the number of errors encountered while performing the insert.

first_error
: If errors were encountered, contains the text of the first error.

deleted, skipped
: 0 for an insert operation.

generated_keys
: a list of generated primary keys in case the primary keys for some documents were missing (capped to 100000).

warnings
: if the field generated_keys is truncated, you will get the warning "Too many generated keys (<X>), array truncated to 100000.".
old_val
: if returnVals is set to true, contains null.
new_val
: if returnVals is set to true, contains the inserted/updated document.

Notice the generated_keys. If you insert a document without set a value for
primary key, whose field name is `*id*` by default, RethinkDB will generate an
UUID[^uuid] for it and return here.

[^uuid]: http://en.wikipedia.org/wiki/Universally_unique_identifier

With our example, we can retreive back the document again.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
    #=>
    {
        "Date":  "May 2" ,
        "Day": 120 ,
        "Dem":  "49" ,
        "id":  "foo" ,
        "uuid":  "13556cd8-034c-4c0e-91c0-666230740121"
    }

Notice the `*uuid*` field? Our table has primary field is `*uuid*` and its value
is set automatically by RethinkDB. 

### Update

To make it easier, you can think of updating like selecting data, then change
their value. We chain `update` method from a selection to update its data.

For example, to update an attribute for a single element

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
          'Dem': 120
      })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0
    }
     

RethinkDB returns an object for the updating result. We can look into `replaced`
field to see if the data is actually updated. If we re-run the above command,
nothing is replaced and we will got 1 `unchanged`.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
          'Dem': 120
      })
    //=>{

      "deleted": 0 ,
      "errors": 0 ,
      "inserted": 0 ,
      "replaced": 1 ,
      "skipped": 0 ,
      "unchanged": 0

    }

That's just how Awesome RethinkDB is. All query result is very verbose. 

To add a new field to exsited document, we just set its value.
    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
          'authors': ['foo']
      })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }
    //Verify
    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
    #=>
    {

        "Date": "May 2" ,
        "Day": 120 ,
        "Dem": 120 ,
        "New Value": 1 ,
        "authors": [
            "foo"
        ] ,
        "id": "foo" ,
        "uuid": "13556cd8-034c-4c0e-91c0-666230740121"

    }

#### Update data for complex field

Now, we got `authors` is an array with only one value of foo. How do we add more
data into its. We can pass an value to the `update`. A naive way, we have to know
the current value, and append a new element. That's just not so efficient
because the array can be big. What we do is to say: *Hey, let append this value
into the `authors` array*. We can do that by using manipulation document method.
`r.row` is a special method returns the currently visited document. By using it,
we can get the value of field we want.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
    		authors: r.row("authors").append('bar')
			})
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

However, if `authors` field isn't existed yet, an error will be throw. To avoid
that, we can tell RethinkDB to set and use an default value when the field isn't
existed.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
    		lol_authors: r.row("lol_authors").append('bar').default([])
			})
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

By calling `default`, we can set an default value for the field. In our case, we
use an empty array [] as default value. 

`append` is a method to manipulation. Besides `append` we can also use
`prepend`. It adds a new element to an array but at the bottom. 

Take another example, we want to count how many time the input_polls is viewed.
We increased its `views` field for one. 


    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        views: r.row('views').add(1)
			})
    //=>
    {

        "deleted": 0 ,
        "errors": 1 ,
        "first_error": "No attribute `views` in object: { "Date": "May 2", "Day": 120, "Dem": 120, "New Value": 1, "authors": ["foo"], "id": "foo", "lol_author": [], "uuid": "13556cd8-034c-4c0e-91c0-666230740121" }" ,
        "inserted": 0 ,
        "replaced": 0 ,
        "skipped": 0 ,
        "unchanged": 0

    } 

Oops, we got an error here because the *views* field has not existed. Let's set
a default value for 1.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        views: r.row('views').add(1).default(1)
			})
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

You can actually use `add` on string, numeric, array fields too. 

Now we know how to work with an array as value of a field, how to work with an
object as value of a field. Consider we have this:


    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        reviewer: {name: 'Vinh', age: 27}
      })
    
The `reviewer` field is an object now. Then we want to add a new field `state` to `reviewer` to denote the `state` of reviewer. We cannot use `append` or `add` on an object. We have to merge current document with something new.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        reviewer: r.row('reviewer').merge({'state': 'CA'})
      })
 
Same as `append`, you can also use `default`:

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
        reviewer: r.row('reviewer').merge({'state': 'CA'}).default({})
      })
 
Since we are working with an object, we set its default value to `{}`.


#### Expression

Beside passing an object into `update`, we can also pass an expression which
returns an object. RethinkDB will evaluate it, get the object result and using
that value for `update` command. It comes in useful when you have some logic
on your document related to the updating. Example, if `views` is greater than
100, we set its type to *host*, otherwise, it's *normal*.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
        update(function(post) {
            return r.branch(
                post("views").gt(100),
                {type: "hot"},
                {type: "normal"}
            )
        })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
    //=>
    {
        "Date": "May 2" ,
        "Day": 120 ,
        "Dem": 120 ,
        "New Value": 1 ,
        "authors": [
            "foo" ,
            "bar"
        ] ,
        "id": "foo-bar" ,
        "type": "normal" ,
        "uuid": "13556cd8-034c-4c0e-91c0-666230740121" ,
        "views": 100
    }




## Replace

To remove one or many fields from document, we cannot use `update` anymore. 
We have to use `replace` method to replace it with a new document. The
new document is constructed from old document without the data we want to
eliminate.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .replace(r.row.without('lol_author'))
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }

We can replace to an entirely new document. However, the primary key cannot be
updated. It has to be same with the current primary key. An attempt to change
the primary key will caused an error **Primary key `uuid` cannot be changed**


    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .replace({

        "Date": "May 2" ,
        "Day": 120 ,
        "Dem": 120 ,
        "New Value": 1 ,
        "authors": [
            "foo", "bar"
        ] ,
        "id": "foo-bar" ,
        "uuid": "13556cd8-034c-4c0e-91c0-666230740121" ,
        "views": 100
    })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0

    }



What if we want to remove an attribute of document. Well, let's set it to
`null`. Depend on your language, you have to use your null value. Such as in
Ruby, it's `nil`.

    r.table('input_polls').get('13556cd8-034c-4c0e-91c0-666230740121')
      .update({
          'Dem': null
      })
    //=>
    {

        "deleted": 0 ,
        "errors": 0 ,
        "inserted": 0 ,
        "replaced": 1 ,
        "skipped": 0 ,
        "unchanged": 0
    }



    


### Delete

Just go ahead and type those command if you want to, we can at any point, reset
to the original data set.

To remove one ore more document, just use ReQL to select what we want and
execute `*delete*` on them.

This will delete a single document. 
    r.table('input_polls').get('id').delete()

Let clear out the vote from florda on may

    r.table('input_polls').filter(function (row) {
      r.row()
    })

Or just wipe an entire table

    r.table().delete()


`delete` method accepts an optional object with:

  * durability: 'hard' or 'soft'. default 'hard' and will override the value of
run.
  * returnVals: 'false' or true. True mean if the document fail to removed for
any reason, it will be returned to your result set. 


How about to wipe out a field or just some. 


### Sync

As you known in the previous chapter, with value of `durability` as 'soft' the
write isn't guarantees to be written to the permanent storage. So after doing a
bunch of those `soft durability`, you may want to said `Hey, I am done all task,
let's make sure you write those change` you can call sync

  r.table('t').sync().run(connection, function () {
    console.log('Syncing is done. All data is safe now')
  })

A sync will run the callback will be called when all change are written to disk.
