-# Reading Data Advanced

## Index

Quickly you will realize that `filter` is slow. If you have a table
with more than 100,000 records, `filter` stops working. All of that is becuase
we haven't used index yet. Without index, we cannot even order data

    r.db("foodb").table("compounds_foods").orderBy(r.desc("id"))
    #->
    RqlRuntimeError: Array over size limit `100000` in:
    r.db("foodb").table("compounds_foods").orderBy(r.desc("id"))
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Without an index, RethinkDB hold all data in memory and sort or filter in
memory. A limit has to lie somewhere else. That 100,000 the magic number of the limit
RethinkDB set to read data without index.


To properpely fetching data, we have to create an Index. And really, in real application, we almost always endup creating index on MySQL  to fetch data efficiently. 

We have two kind of indexes in RethinkDB

* primary index: our ID key is this. This index is created automatically by
RethinkDB. Coming back above query, if we change it to use primary `index`

    r.db("foodb").table("compounds_foods").orderBy({index: r.desc("id")})

`id` field is always indexed automatically.

* secondary index:

Seconday index is the index we created ourselve on one or many fields. Secondary
index can be simple, just index the value of fields directly, or doing some
pre-calculate on data before indexing.

While index helps to decrease the reading time, it decreases writing time, also cost
storage space. It reduces write performance becuase whenever we inserted a
document, the index has to be calculate and writing into the database.

RethinkDB supports those kinds of index:

*Simple
:indexes based on the value of a single field.
*Compound
:indexes based on multiple fields.
*Multi 
:indexes based on arrays of values.
*Indexes 
:based on arbitrary expressions.

So now you know what index is. But a sad news is that filter cannot use those secondary index. FOr that purpose we have to use other functions: `getAll` and `between`. 
### Creating index

Let's start with simple index first.

#### Simple index

As its name, simple index is simply a single field. Let's say we want to find all `compounds_foods` whose name contains `banana`. We cannot use `filter` here because this table has more than 100,000 item. `filter` also doesn't use index. Let's meet `getAll`. `getAll` grabs all document where a given key match the index which we specified.

First, we create index follow this syntax

    table.index_create(index_name[, index_function][, :multi => false]) → object

Apply it on our case, for a single column:

    r.db("foodb")
      .table("compounds_foods")
      .indexCreate("match_orig_food_common_name", r.row.match)

If we don't pass an index function, RethinkDB try to create index for the column of same name as requested index name.

Time to use it:

    r.db("foodb")
      .table("compounds_foods")
      .getAll('Bananas', {index:'orig_food_common_name'})
    #=> Executed in 10ms. No results returned.

No result. Strange, we cannot believe we have no document where its
orig_food_common_name doesn't contain banana. Why so? Well, the simple
index does an exact match, or in other world, it's an equal comparison.
Let's try an exact match:

    r.db("foodb")
      .table("compounds_foods")
      .getAll('Bananas, raw', {index:'orig_food_common_name'})
    #=> Executed in 69ms. 40 rows returned, 40 displayed, more available
    {
    "citation":  "USDA" ,
    "citation_type":  "DATABASE" ,
    "compound_id": 2100 ,
    "created_at": Tue Jan 03 2012 18:33:15 GMT-08:00 ,
    "creator_id": null ,
    "food_id": 208 ,
    "id": 257686 ,
    "orig_citation": null ,
    "orig_compound_id":  "262" ,
    "orig_compound_name":  "Caffeine" ,
    "orig_content":  "0.0" ,
    "orig_food_common_name":  "Bananas, raw" ,
    "orig_food_id":  "09040" ,
    "orig_food_part": null ,
    "orig_food_scientific_name": null ,
    "orig_max": null ,
    "orig_method": null ,
    "orig_min": null ,
    "orig_unit":  "mg" ,
    "orig_unit_expression": null ,
    "updated_at": Tue Jan 03 2012 18:33:15 GMT-08:00 ,
    "updater_id": null
    }

We can pass multiple keys to `getAll` to have an `or` effect. Meaning RethinkDB
returns document where the index match any of value that we pass.

    r.db("foodb")
      .table("compounds_foods")
      .getAll('Bananas, raw', 'Yoghurt with pear and banana', 'Alfalfa seeds',{index:'orig_food_common_name'})

We can chain to `count` to count how many document we have

    r.db("foodb")
      .table("compounds_foods")
      .getAll('Bananas, raw', 'Yoghurt with pear and banana', 'Alfalfa seeds',{index:'orig_food_common_name'})
      .count()
    #=> 256

Not only use to find document, index can be used for sorting as well. To sort,
we call `orderBy` and passing index name.

    r.db("foodb").table("compounds_foods")
      .orderBy({index: "orig_food_common_name"})

When passing index, we can wrap it in other expression to change ordering:

    r.db("foodb").table("compounds_foods")
      .orderBy({index: r.desc("orig_food_common_name")})
      .withFields("orig_food_common_name")
    #=> 
    {
    "orig_food_common_name":  "Zwieback"
    } {
    "orig_food_common_name":  "Zwieback"
    } {
    "orig_food_common_name":  "Zwieback"
    }

Using `withFields`, we can pass a list of field to choose what we want to get
back.

Because index can be used to sort, we can use it to find the value between a
range. In RethinkDB, `between` syntax is:

    table.between(lowerKey, upperKey[, {index: 'id', leftBound: 'closed',
rightBound: 'open'}]) → selection

As you see, we can only use between on table type. So, note that.
Use this we can find the document between "Apple" and "Banana" range.

    r.db("foodb").table("compounds_foods")
      .between("Apple", "Banana", {index: 'orig_food_common_name'})
      .orderBy({index: r.desc("orig_food_common_name")})
      .withFields("orig_food_common_name")

Without specifying an index, `between` operates on primary index. Many RethinkDB 
function has same behaviour

    r.db("foodb").table("compounds_foods")
      .between(1, 200)
      .count()
    #=> 198

This work when we want to find data based on a single field. How about find
value base on multiple field. Let's meet compound index

##### Compound index

Compound index is created by using value of multiple fields. It's very similar to
single index in syntax, just different on how many fields we pass to index
create. Let's look at `compounds_foods` table, it contains relation ship of
`foods` and `compounds`. We will learn more about JOIN later. For now, let's say
we want to find all `compounds_foods` document where its `compound_id` is 3524
and `food_id` is 287. We are finding on two columnds, so we need an index
contains those 2 columns:

    r.db("foodb").table("compounds_foods")
      .indexCreate("compound_food_id", [r.row(row"compound_id"), r.row("food_id")]) 

The only different with simple index is we have to pass an array of field to
create index. Let's try it:

    r.db("foodb").table("compounds_foods")
      .getAll([354,287], {index: 'compound_food_id'})
    #=>
    RqlRuntimeError: Index `compound_food_id` on table `foodb.compounds_foods` was
    accessed before its construction was finished in:
    r.db("foodb").table("compounds_foods").getAll([354, 287], {index:
    "compound_food_id"})
    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

We got an error. Looks like the index is not completed created yet. The table
has 

We can query index status:

    r.db("foodb").table("compounds_foods")
      .indexStatus('compound_food_id')
    #=>
    [
    {
    "blocks_processed": 13192 ,
    "blocks_total": 15437 ,
    "function": <binary, 408 bytes, "24 72 65 71 6c 5f..."> ,
    "geo": false ,
    "index":  "compound_food_id" ,
    "multi": false ,
    "outdated": false ,
    "ready": false
    }
    ]

The field ready is false. We can only wait until it finish. This table is very
big. We can verify:

    r.db("foodb").table("compounds_foods").count()
    #=> 737089

Let's just wait for bit, make a cup of coffee and come back :). When it's ready
you should see:

    r.db("foodb").table("compounds_foods")
      .indexStatus('compound_food_id')

    [
    {
    "function": <binary, 408 bytes, "24 72 65 71 6c 5f..."> ,
    "geo": false ,
    "index":  "compound_food_id" ,
    "multi": false ,
    "outdated": false ,
    "ready": true
    }
    ]

Now, try it:
    
    r.db("foodb").table("compounds_foods")
      .getAll([21477,899], {index: 'compound_food_id'})
    #=> Executed in 7ms. 1 row returned
    {
    "citation":  "DFC CODES" ,
    "citation_type":  "DATABASE" ,
    "compound_id": 21477 ,
    "created_at": Tue Sep 11 2012 16:12:30 GMT-07:00 ,
    "creator_id": null ,
    "food_id": 899 ,
    "id": 740574 ,
    "orig_citation": null ,
    "orig_compound_id": null ,
    "orig_compound_name": null ,
    "orig_content": null ,
    "orig_food_common_name":  "Meats" ,
    "orig_food_id":  "WI8000" ,
    "orig_food_part": null ,
    "orig_food_scientific_name": null ,
    "orig_max": null ,
    "orig_method": null ,
    "orig_min": null ,
    "orig_unit": null ,
    "orig_unit_expression": null ,
    "updated_at": Tue Sep 11 2012 16:12:30 GMT-07:00 ,
    "updater_id": null
    }

With above indexing approach, you found that you have to crate a dedicated index
for whatever you want to find. An index contains a single value for a document:
either a single value of field, or an order set of value in case of compound
index. But life is not that simple. Let's looking at `users` table. It contains
a list of user and their three of most faviroute food, store in field
`favfoods`. That's a single column. But it hold many elements. Because of that,
we cannot simple answer the question who liked `Mushroom`:

let's create an index

    r.db("foodb").table("users").indexCreate('favfoods')

Try to find all user who liked mushrooms.

    r.db("foodb").table("users")
      .getAll('Mushrooms', {index: 'favfoods'})
    #=> Executed in 6ms. No results returned.

Why so? Because we index the whole field as a single value, we have to match the
whole value of field:

    r.db("foodb").table("users")
      .getAll(["Edible shell" ,
        "Clupeinae (Herring, Sardine, Sprat)" ,
        "Deer" ,
        "Perciformes (Perch-like fishes)" ,
        "Bivalvia (Clam, Mussel, Oyster)"], {index: 'favfoods'})
    #=>
    {
    "favfoods": [
    "Edible shell" ,
    "Clupeinae (Herring, Sardine, Sprat)" ,
    "Deer" ,
    "Perciformes (Perch-like fishes)" ,
    "Bivalvia (Clam, Mussel, Oyster)"
    ] ,
    "id":  "1dd8059c-82ca-4345-9d75-eaa0f8edbf48" ,
    "name":  "Arthur Hegmann"
    }

*Multi index* is used to solve above question: who likes Banana. An multi index
is used on multiple value, or in other word, an array of value. When RethinkDB
see that we want to use a *multi index*, it try to loop over all value in the
array of index, and match to each of element of array.

To create a multi index, all we have to do is pass the option flag:` multi:
true`


    r.db("foodb").table("users").indexCreate('favfoods_multi', r.row("favfoods"), {multi: true})

Now, try it:

    r.db("foodb").table("users")
      .getAll('Mushrooms', {index: 'favfoods_multi'})
    #=>
    {
    "favfoods": [
    "Milk substitute" ,
    "Mushrooms" ,
    "Nuts" ,
    "Hummus" ,
    "Soft-necked garlic"
    ] ,
    "id":  "47110a8f-3c2c-46b8-96d8-244747c1818b" ,
    "name":  "Annabelle Lindgren"
    }

If you notice, we have to pass `r.row(favfoods)` to create an index. Remember
that to create an index where its name doesn't match any field, we have to pass
an expression or an anonymous fuction to `indexCreate` to caculate its value.
But we defined `favfoods` index before, so now we cannot create other index with
same name. Can we go back, delete index to clear thing up and save our
namespace:

    r.db("foodb").table("users").indexDrop('favfoods')
    #=> 
    { "dropped": 1 } 
    r.db("foodb").table("users").indexDrop('favfoods_multi')
    #=> 
    { "dropped": 1 } 

Now, let create an multile index with same field name:

    r.db("foodb").table("users").indexCreate('favfoods', {multi: true})
    r.db("foodb").table("users").getAll('Mushrooms', {index: 'favfoods'})
    #=>
    {
    "favfoods": [
    "Milk substitute" ,
    "Mushrooms" ,
    "Nuts" ,
    "Hummus" ,
    "Soft-necked garlic"
    ] ,
    "id":  "47110a8f-3c2c-46b8-96d8-244747c1818b" ,
    "name":  "Annabelle Lindgren"
    }

Another question come up? Can we find all user who like `Mustrooms` and
`Banana`. We may try this:

    r.db("foodb").table("users")
      .getAll('Kiwi', 'Banana', {index: 'favfoods'})

However, that's an `or`. RethinkDB will return documents where its index value
matches either `Kiwi` or `Banana`.

Even more complex, we want to find user who like Kiwi most. Meaning `kiwi` has
to be first element in ther *favfoods* array.

To do that, we see that we are passing business logic into RethinkDB. We have to
somehow represent that logic in RethinkDB, calculate the value, and index the
return value. Let's meet `arbitrary expressions` index. 

##### Arbitray expressions index

As its name, the returned value of expression is used to calculate index. 

Unfortunately at this moment, we cannot simple answer who like both of banana
and kiwi. We will save it for later chapter: map-reduce. Now, let's find user
who like kiwi most. With assumption that the first element of `favfoods` array
is what an user like most.

    r.db("foodb").table("users")
      .indexCreate('most-favourite-food', function (user) {
        return user("favfoods").nth(0)
      })

Given an array, `nth(n)` return n-th element. We call `nth(0)` on array
`favfoods`  that means first
element of array since they are zero-base index.

    r.db("foodb").table("users")
      .getAll('Kiwi', {index: 'most-favourite-food-1'})
    #=>
    {
    "favfoods": [
    "Kiwi" ,
    "Lemon" ,
    "Lime" ,
    "Coffee" ,
    "Sweet orange"
    ] ,
    "id":  "0b83164e-fb42-4273-8db1-ba12be6e580d" ,
    "name":  "Carl Achiban"
    } {
    "favfoods": [
    "Kiwi" ,
    "Banana" ,
    "Peanut" ,
    "Asparagus" ,
    "Common cabbage"
    ] ,
    "id":  "d10b51d7-d321-4b41-bd7d-1367ede0eb30" ,
    "name":  "Luma Ramses"
    }

This index is powerful because we can push more complex searching to database
engine. Let's say we want to find all user who like `Kiwi` most and is a female.

    r.db("foodb").table("users")
      .indexCreate('most-favourite-food-gender', function (user) {
        return [user("gender"), user("favfoods").nth(0)]
      })

Here, we are trying to create non-multi index. The index is an array of gender
and most like food item. Now, let's try our index

    r.db("foodb").table("users")
      .getAll(['f', 'Kiwi'], {index: 'most-favourite-food-gender'})
    #=>
    {
    "favfoods": [
    "Kiwi" ,
    "Lemon" ,
    "Lime" ,
    "Coffee" ,
    "Sweet orange"
    ] ,
    "gender":  "f" ,
    "id":  "0b83164e-fb42-4273-8db1-ba12be6e580d" ,
    "name":  "Carl Achiban"
    } {
    "favfoods": [
    "Kiwi" ,
    "Banana" ,
    "Peanut" ,
    "Asparagus" ,
    "Common cabbage"
    ] ,
    "gender":  "f" ,
    "id":  "d10b51d7-d321-4b41-bd7d-1367ede0eb30" ,
    "name":  "Luma Ramses"
    }

One thing I want to remind you(well, myself actually) is that the return
function in any RethinkDb expression is evaludated on RethinkDB, not on client
language. You cannot just write anything. You have to use RethinkDB expression
in return value so that RethinkDB can calculated it. In previous chapter, we
learn about `expr`, you can use that to turn native object into RethinkDb object
when wanting.

Let's look at this example:

    r.table("users").indexCreate("full_name2", function(user) {
        return r.add(user("last_name"), "_", user("first_name"))
    }).run(conn, callback)

We are trying to create an index by appending *last_name* and *first_name*. We
cannot write

    return user("last_name") + user("first_name")

because ReThinkDB won't understand that expression. We have to call `r.add`
function.

However, even if you see something like 

    return user("last_name") + user("first_name")

That's doesn't mean RethinkDB understand your native expression. It's actually
your driver overload operator (`+` operator) in this case because your host
language apparently support operator overloading.

If you notice, we don't pass `multi: true` in any of above examples. Can we use
multi index with arbitray expression index? Yes, we can.

Let's say if we can find any users who like `Kiwi` or used to eat Kiwi. We will
create an multi index by concat array `favfoods` and `eatenfoods`


    r.db("foodb").table("users")
      .indexCreate(
        'eateen-or-like-multi', 
        r.add(r.row("eatenfoods"), r.row("favfoods"))
        , {multi: true})

Now, we can use that index:


    r.db("foodb").table("users")
      .getAll('Kiwi', {index:'eateen-or-like-multi'})
    #=>
    {
    "eatenfoods": [
    "Celery leaves" ,
    "Kiwi" ,
    "Rainbow trout" ,
    "Chinese bayberry" ,
    "Hyacinth bean" ,
    "Other sandwich"
    ] ,
    "favfoods": [
    "Honey" ,
    "Cake" ,
    "Butter substitute" ,
    "Cream" ,
    "Sugar"
    ] ,
    "gender":  "m" ,
    "id":  "808cedd5-f2ac-4724-98bc-061ee84755c9" ,
    "name":  "Forrest Jacobs"
    } {
    "eatenfoods": [
    "Jerusalem artichoke" ,
    "Conch" ,
    "Milk and milk products" ,
    "Dumpling" ,
    "Custard apple" ,
    "Sacred lotus" ,
    "Japanese walnut" ,
    "Crab"
    ] ,
    "favfoods": [
    "Kiwi" ,
    "Banana" ,
    "Peanut" ,
    "Asparagus" ,
    "Common cabbage"
    ] ,
    "gender":  "f" ,
    "id":  "d10b51d7-d321-4b41-bd7d-1367ede0eb30" ,
    "name":  "Luma Ramses"
    }
    
How about finding user liked Kiwi most and have eaten kiwi? We just need to
change the index function, this time we will use anonymous function:

    r.db("foodb").table("users")
      .indexCreate(
        'eatean-or-like-most',
        function (user) {
          return r.add(user("eatenfoods"), [user("favfoods").nth(0)])
        }
        , {multi: true})

Really, function is just a special case of expression where expression is
result of function executing. Now, we can try to find:

    r.db("foodb").table("users")
      .getAll('Kiwi', {index: 'eatean-or-like-most'})
    #=>
    {
        "eatenfoods": [
            "Shrimp",
            "Other fish product",
            "Sweet orange",
            "Unclassified food or beverage"
        ],
        "favfoods": [
            "Kiwi",
            "Lemon",
            "Lime",
            "Coffee",
            "Sweet orange"
        ],
        "gender": "f",
        "id": "0b83164e-fb42-4273-8db1-ba12be6e580d",
        "name": "Carl Achiban"
    } {
        "eatenfoods": [
            "Celery leaves",
            "Kiwi",
            "Rainbow trout",
            "Chinese bayberry",
            "Hyacinth bean",
            "Other sandwich"
        ],
        "favfoods": [
            "Honey",
            "Cake",
            "Butter substitute",
            "Cream",
            "Sugar"
        ],
        "gender": "m",
        "id": "808cedd5-f2ac-4724-98bc-061ee84755c9",
        "name": "Forrest Jacobs"
    } {
        "eatenfoods": [
            "Jerusalem artichoke",
            "Conch",
            "Milk and milk products",
            "Dumpling",
            "Custard apple",
            "Sacred lotus",
            "Japanese walnut",
            "Crab"
        ],
        "favfoods": [
            "Kiwi",
            "Banana",
            "Peanut",
            "Asparagus",
            "Common cabbage"
        ],
        "gender": "f",
        "id": "d10b51d7-d321-4b41-bd7d-1367ede0eb30",
        "name": "Luma Ramses"
    }



### Checking index status

As I said above, indexing reduces write performance, therefore it takes time to
create after we issue creating command. Depend on the table size, how many
records we have, we have to wait for an amout of time before using it. We can
check the status of an index to see if it's ready to use

    r.table().indexStatus(indexName)

Sometimes we just want to say, when the index is ready, please run this:

    r.table.indexWait


### Using index

### Order

Sorting with order without index limit to 100k issue

### Pagination

To pagination data, we will use a a combination of `skip`, `limit` and `slice`.

**skip(n)**

: Skip a number of element from the begining of sequence or array

**limit(n)**

: End the sequence after we read up to the give number of limit

**slice

T> ## Where else I can call Skip, Limit, Slice
T>
T> These command can be called on a selection, an array or stream. So you ca

## Map Reduce

Coming back our question, find users who like *kiwi* and *banana*. To recap, we
cannot use a single index because that's only match the whole document. We
cannot use compound index, because we have an only single field to index. We
cannot use multi index, because that's an or. This leaves us with only arbitrary
index. However, how we are going to create index for it? A non-multi index is
not usable here. More detail here...

Let's meep map reduce. 

# Wrap up

This chapter is quite long. So far we learn about index. We know how to create:

  * Simple index
  * Compound index
  * Multi value index
  * Arbitrary expression index

We also learn how to leverage index to sort, filter data.
